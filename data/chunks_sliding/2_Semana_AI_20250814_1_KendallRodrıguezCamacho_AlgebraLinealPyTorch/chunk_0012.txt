Tensor resultante de forma 3x2 I. Operaciones in-place Las operaciones in-place modifican directamente el tensor original, ahorrandose memoria. Esto esutil cuando se maneja muchos parametros y se quiere evitar crear copias innecesarias. before = id(Y) # Se guarda la direccion de memoria original de Y Y = Y + X # Se crea un nuevo tensor con la suma; Y ahora apunta a nueva memoria id(Y) == before # False, la memoria de Y cambio Z = torch.zeros_like(Y) # Se crea un tensor Z con la misma forma que Y, lleno de ceros Z[:] = X + Y # Modifica el contenido de Z directamente (in-place), sin cambiar su direccion de memoria Se recomienda usar in-place para eficiencia, pero con cuidado si varias variables apuntan al mismo tensor, para evitar inconsistencias. J. Conversion a NumPy PyTorch permite convertir tensores a arreglos de NumPy y viceversa, sin duplicar los datos en memoria: A_np = A.numpy() # Tensor a arreglo NumPy type (A_np) A_back = torch.from_numpy(A_np) # Arreglo NumPy a tensor type (A_back) K. Carga de datos desde CSV Para trabajar con datos externos, se puede usar pandas y luego convertir a tensores de PyTorch. Se pueden aplicar codificacion *one-hot* y completar valores faltantes: import pandas as pd import torch df = pd.read_csv(’../data/house_tiny.csv’) # Leer CSV inputs = df.iloc[:, :2] # Seleccionar columnas inputs = pd.get_dummies(inputs, dummy_na=True) # One-hot encoding inputs = inputs.fillna(inputs.mean()) # Completar valores faltantes X_csv = torch.tensor(inputs.to_numpy(dtype= float ))